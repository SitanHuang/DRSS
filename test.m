%% Misc Setup

clear;

addpath(fullfile(fileparts(mfilename('fullpath')), 'VADL'))
addpath(fullfile(fileparts(mfilename('fullpath')), 'VADL/Motor Data'))

uc = DRSS.util.unitConv;

%% Define rocket sections

rocketCylindricalGeometry = struct( ...
    'Ri', (6.125 - 0.25) / 2 * uc.in_to_m, ...
    'Ro', 6.125 / 2 * uc.in_to_m ...
);

noseCone = DRSS.core.obj.Mass("Nose Cone") ...
    .setM(2.7211) ...
    .setLen(8.75 * uc.in_to_m) ...
    .setCGX(10.3300 * uc.in_to_m);
payloadBay = DRSS.core.obj.Mass("Payload bay") ...
    .setM(3.6287) ...
    .setLen(36 * uc.in_to_m) ...
    .setCGX(22.6789 * uc.in_to_m);
recoveryBay = DRSS.core.obj.Mass("Recovery bay") ...
    .setM(7.478272727) ...
    .setLen(28.5 * uc.in_to_m) ...
    .setCGX(13.586 * uc.in_to_m);
tail = DRSS.core.obj.Mass("Tail") ...
    .setM(3.1890) ...
    .setLen(28 * uc.in_to_m) ...
    .setCGX(9.0820 * uc.in_to_m);

%% Define Dynamics

gravityDynamics = DRSS.core.dynamics.Gravity() ...
    .setEPS(800 * uc.ft_to_m) ... % set launch site elevation above mean sea level
    .setTerminateOnGrounding(true);

motorDynamics = DRSS.core.dynamics.Motor( ...
    fullfile(fileparts(mfilename('fullpath')), 'VADL/Motor Data/L1170.csv'), ...
    "L1170", @drss_motor_database);
motor = motorDynamics.genMotorMass(); % the motor Mass is automatically bound to this motorDynamics

%% Simulate Powered Rail Ascent

% System must be the top level MassGroup to calculate
% correctly the sectional moments of inertia; this is
% because non-System MassGroups calculate moments of
% inertia by assuming homogenous distribution in length
sys = DRSS.core.sim.System("Powered Rail Ascent") ...
    .appendChild(noseCone) ...
    .appendChild(payloadBay) ...
    .appendChild(recoveryBay) ...
    .appendChild(tail) ...
    .appendChild(motor) ...
    .setGeometryRecursive(rocketCylindricalGeometry) ...
    .subjecTo(gravityDynamics) ...
    .subjecTo(rocketDynamics) ...
    .subjecTo(motorDynamics);

solver = DRSS.solver.ODE45Solver(sys) ...
    .solve();

%% Debug & dev only:

% sys.momentOfInertia

% ss = DRSS.core.sim.SystemState.createZeroState();
% ss.theta = deg2rad(5);
% ss.t = 0.5;


% [gravityDynamics, sys]=gravityDynamics.step(sys, ss);
% [motorDynamics, sys]=motorDynamics.step(sys, ss);
% [gravityDynamics, sys, terminate, xdd, ydd, tdd, mdot] = gravityDynamics.resolve(sys, ss)
% [motorDynamics, sys, terminate, xdd, ydd, tdd, mdot] = motorDynamics.resolve(sys, ss)